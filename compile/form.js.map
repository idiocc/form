{
"version":3,
"file":"compile/form.js",
"lineCount":387,
"mappings":"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",
"sources":["node_modules/fs/index.js","node_modules/stream/index.js","node_modules/erotic/src/lib.js","node_modules/os/index.js","node_modules/@artdeco/clean-stack/src/index.js","node_modules/erotic/src/callback.js","node_modules/erotic/src/index.js","node_modules/catchment/src/lib/index.js","node_modules/catchment/src/index.js","node_modules/@wrote/read/src/index.js","node_modules/tty/index.js","node_modules/util/index.js","node_modules/@idio/debug/src/ms.js","node_modules/@idio/debug/src/bytes.js","node_modules/erte/src/index.js","node_modules/@idio/debug/src/modifiers/f.js","node_modules/@idio/debug/src/node.js","node_modules/@idio/debug/src/common.js","src/index.js","node_modules/@idio/debug/src/index.js","src/depack.js"],
"sourcesContent":["export default fs\nexport const {\n  ReadStream,\n  Stats,\n  WriteStream,\n  access,\n  accessSync,\n  appendFile,\n  appendFileSync,\n  chmod,\n  chmodSync,\n  chown,\n  chownSync,\n  close,\n  closeSync,\n  constants,\n  copyFile,\n  copyFileSync,\n  createReadStream,\n  createWriteStream,\n  exists,\n  existsSync,\n  fchmod,\n  fchmodSync,\n  fchown,\n  fchownSync,\n  fdatasync,\n  fdatasyncSync,\n  fstat,\n  fstatSync,\n  fsync,\n  fsyncSync,\n  ftruncate,\n  ftruncateSync,\n  futimes,\n  futimesSync,\n  lchmod,\n  lchmodSync,\n  lchown,\n  lchownSync,\n  link,\n  linkSync,\n  lstat,\n  lstatSync,\n  mkdir,\n  mkdirSync,\n  mkdtemp,\n  mkdtempSync,\n  open,\n  openSync,\n  read,\n  readFile,\n  readFileSync,\n  readSync,\n  readdir,\n  readdirSync,\n  readlink,\n  readlinkSync,\n  realpath,\n  realpathSync,\n  rename,\n  renameSync,\n  rmdir,\n  rmdirSync,\n  stat,\n  statSync,\n  symlink,\n  symlinkSync,\n  truncate,\n  truncateSync,\n  unlink,\n  unlinkSync,\n  unwatchFile,\n  utimes,\n  utimesSync,\n  watch,\n  watchFile,\n  write,\n  writeFile,\n  writeFileSync,\n  writeSync,\n} = fs","export default stream\nexport const {\n  Duplex,\n  PassThrough,\n  Readable,\n  Stream,\n  Transform,\n  Writable,\n} = stream","const getLastItem = (array) => {\n  const item = array[array.length - 1]\n  return item\n}\nconst getItemsFrom = (array, from) => array.slice(from)\n\n/**\n * Get a segment of the stack string, defaults are from = 0 and oneLine = false.\n * @param {string} stack the stack string\n * @param {number} [from=0] index from which to slice from\n * @param {boolean} [oneLine=false] Whether just first line must be returned\n * @returns {string} A stack segment starting from the specified line.\n */\nexport const getStackSegment = (stack, from = 0, oneLine = false) => {\n  if (from === 0 && !oneLine) {\n    return stack\n  }\n  const splitStack = stack\n    .split('\\n', oneLine ? from + 1 : undefined)\n  if (oneLine) {\n    const line = getLastItem(splitStack)\n    return line\n  } else {\n    const items = getItemsFrom(splitStack, from)\n    return items.join('\\n')\n  }\n}\n\n/**\n * Get the stack trace part of when the erotic function was called. Disregards\n * first two lines.\n * @param {string} stack error's stack\n * @param {boolean} [transparent] trim the top line as well\n * @returns {string} A part of stack\n */\nexport const getEntryStack = (stack, transparent = false) => {\n  const stackSegment = getStackSegment(stack, 2 + (transparent ? 1 : 0))\n  return stackSegment\n}\n\n/**\n * Get stack line of where the callback was called.\n * @param {string} stack Stack string.\n * @returns {string} Stack line.\n */\nexport const getCalleeStackLine = (stack) => {\n  const calleeStackLine = getStackSegment(stack, 2, true)\n  return calleeStackLine\n}\n\nexport const getStackHeading = message => `Error: ${message}`\n\n/**\n * Extract caller from the function's `arguments`.\n * @param {Object} args arguments\n * @returns {!Function} The caller function from `arguments.callee.caller`.\n */\nexport const getCallerFromArguments = (args) => {\n  const { callee: { caller } } = args\n  return caller\n}","export default os\nexport const {\n  EOL,\n  arch,\n  constants,\n  cpus,\n  endianness,\n  freemem,\n  homedir,\n  hostname,\n  loadavg,\n  networkInterfaces,\n  platform,\n  release,\n  tmpdir,\n  totalmem,\n  type,\n  uptime,\n  userInfo,\n} = os","import { homedir } from 'os'\n\nconst extractPathRegex = /\\s+at.*(?:\\(|\\s)(.*)\\)?/\nconst pathRegex = /^(?:(?:(?:node|(?:internal\\/[\\w/]*|.*node_modules\\/(?:IGNORED_MODULES)\\/.*)?\\w+)\\.js:\\d+:\\d+)|native)/\n\nconst homeDir = homedir()\n\n/**\n * Remove internal Node.JS lines from the error stack traces.\n * @param {string} stack The error stack to update.\n * @param {!_cleanStack.Config} [options] Options for the program.\n * @param {boolean} [options.pretty=false] Replace the absolute path to the home directory with the `~`. Default `false`.\n * @param {!Array<string>} [options.ignoredModules=\"\uff3b'pirates'\uff3d\"] Which modules to ignore in the path. Default `\uff3b'pirates'\uff3d`.\n */\nconst cleanStack = (stack, options) => {\n  const {\n    pretty = false, ignoredModules = ['pirates'],\n  } = options || {}\n  const j = ignoredModules.join('|')\n  const re = new RegExp(pathRegex.source.replace('IGNORED_MODULES', j))\n\n  return stack.replace(/\\\\/g, '/')\n    .split('\\n')\n    .filter(x => {\n      const pathMatches = x.match(extractPathRegex)\n      if (pathMatches === null || !pathMatches[1]) {\n        return true\n      }\n\n      const match = pathMatches[1]\n\n      // Electron\n      if (match.includes('.app/Contents/Resources/electron.asar') ||\n        match.includes('.app/Contents/Resources/default_app.asar')) {\n        return false\n      }\n\n      return !re.test(match)\n    })\n    .filter(x => x.trim())\n    .map(x => {\n      if (pretty) {\n        return x.replace(extractPathRegex, (m, p1) => m.replace(p1, p1.replace(homeDir, '~')))\n      }\n\n      return x\n    })\n    .join('\\n')\n}\n\nexport default cleanStack\n\n/* documentary types/index.xml */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {_cleanStack.Config} Config Options for the program.\n */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {Object} _cleanStack.Config Options for the program.\n * @prop {boolean} [pretty=false] Replace the absolute path to the home directory with the `~`. Default `false`.\n * @prop {!Array<string>} [ignoredModules=\"\uff3b'pirates'\uff3d\"] Which modules to ignore in the path. Default `\uff3b'pirates'\uff3d`.\n */\n","import cleanStack from '@artdeco/clean-stack'\nimport {\n  getCallerFromArguments, getCalleeStackLine, getStackHeading,\n} from './lib'\n\n/**\n * Create a callback.\n * @param {!Function} entryCaller The function which was called at entry.\n * @param {string} entryStack The first line of the error stack to be returned\n * @param {boolean} [shadow=false] Print only entry stack.\n */\nexport function makeCallback(entryCaller, entryStack, shadow = false) {\n  /**\n   * This callback should be called when an asynchronous error occurred.\n   * @param {(string|Error)} messageOrError A message string or an _Error_ object at the point of actual error.\n   * @returns {Error} An error with the updated stack which includes the callee.\n   */\n  function cb(messageOrError) {\n    const caller = getCallerFromArguments(arguments)\n    const { stack: errorStack } = new Error()\n    const calleeStackLine = getCalleeStackLine(errorStack)\n    const isError = messageOrError instanceof Error\n    const message = isError ? messageOrError.message : messageOrError\n\n    const stackHeading = getStackHeading(message)\n    const entryHasCallee = caller !== null && entryCaller === caller\n    const stackMessage = [\n      stackHeading,\n      ...(entryHasCallee || shadow ? [entryStack] : [\n        calleeStackLine,\n        entryStack,\n      ]),\n    ].join('\\n')\n\n    const stack = cleanStack(stackMessage)\n    const properties = { message, stack }\n    const e = isError ? messageOrError : new Error()\n\n    return /** @type {Error} */ (Object.assign(/** @type {!Object} */ (e), properties))\n  }\n\n  return cb\n}","import {\n  getEntryStack, getCallerFromArguments,\n} from './lib'\nimport { makeCallback } from './callback'\n\n/**\n * Returns a function to create an error with a stack trace starting at the line in code when the call was made by the callee.\n * @param {boolean} [transparent] Pretend as if the call to the function lead to the error, without exposing any of the internal stack.\n */\nexport default function erotic(transparent) {\n  const { stack } = new Error()\n  const caller = getCallerFromArguments(arguments)\n  const entryStack = getEntryStack(stack, transparent)\n\n  return makeCallback(caller, entryStack, transparent)\n}","/**\n * Listens for the `error` event once so that when an error in _streamB_ is emitted, is is also emitted in the _streamA_.\n * @param {stream.Stream} streamA The stream that will emit an error once it's caught in the `streamB`.\n * @param {stream.Stream} streamB The stream from which the error originates.\n * @returns The stream the error is listened on, i.e., transparent to calling the `.once` method on that stream.\n */\nexport const pipeError = (streamA, streamB) => {\n  streamB\n    .once('error', e => {\n      streamA.emit('error', e)\n    })\n  return streamB\n}\n\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {import('stream').Stream} stream.Stream\n */","import { Writable } from 'stream'\nimport erotic from 'erotic'\nimport cleanStack from '@artdeco/clean-stack'\nimport { pipeError } from './lib'\n\nfunction joinBufferData(array) {\n  return array.join('')\n}\n\n/**\n * A writable stream which collects incoming data into memory, and provides a promise to way for the stream to finish. The promise is resolved with joined chunks.\n */\nexport default class Catchment extends Writable {\n  /**\n   * Create a new catchment to pipe a readable stream into and collect all emitted data.\n   * @param {!_catchment.Options} [options] Options to pass to the `Writable` super constructor, and others shown below.\n   * @param {!stream.Readable} [options.rs] A readable stream to automatically pipe into the catchment. If an error occurs during reading of this stream, the catchment promise will be rejected with it.\n   * @param {boolean} [options.binary=false] Whether to return a raw buffer instead of a string. The string is created by joining all incoming chunks together with `.join('')` method. Default `false`.\n   * @example\n   *\n   * import { createReadStream } from 'fs'\n   * import Catchment from 'catchment'\n   *\n   * const rs = createReadStream('file.txt')\n   * const { promise } = new Catchment({ rs })\n   * const res = await promise\n   */\n  constructor(options) {\n    const {\n      binary = false, rs = null, ...opts\n    } = options || {}\n    /** @suppress {missingProperties} */\n    const { er = erotic(true), proxyError } = options || {}\n    const wrap = (_, e) => er(e)\n    super(/** @type {!stream.WritableOptions} */ (opts))\n    this._caughtData = []\n    this._promise = new Promise((r, j) => {\n      this.on('finish', () => {\n        let d\n        if (binary) {\n          d = Buffer.concat(this._caughtData)\n        } else {\n          d = joinBufferData(this._caughtData)\n        }\n        r(d)\n        this._caughtData = []\n      })\n      this.once('error', (e) => {\n        if (e.stack.indexOf('\\n') == -1) {\n          wrap`${e}`\n          j(e)\n        } else {\n          const stack = cleanStack(e.stack)\n          e.stack = stack\n          if (proxyError) wrap`${e}`\n          j(e)\n        }\n      })\n      if (rs) {\n        pipeError(this, rs).pipe(this)\n      }\n    })\n  }\n  _write(chunk, encoding, callback) {\n    this._caughtData.push(chunk)\n    callback()\n  }\n  /**\n   * A promise which will resolve will all data when the stream finishes.\n   * @type {Promise<string|Buffer>}\n   */\n  get promise() {\n    return this._promise\n  }\n}\n\n/**\n * Collect data into a catchment, and return results when the stream finishes.\n * @param {stream.Readable} readable A readable stream to collect all data from. If an error occurs during reading of this stream, the promise will be rejected with it.\n * @param {_catchment.CollectOptions} options Options when collecting data into a catchment. They can extend `Writable` options which will be passed to the `Catchment` constructor.\n * @param {boolean} [options.binary=false] Whether to return a raw buffer instead of a string. The string is created by joining all incoming chunks together with `.join('')` method. Default `false`.\n * @param {boolean} [options.proxyError=false] Sets whether an error emitted by the stream with have its stack start at the line where the `collect` was called rather than inside of the stream. In other words, hides the implementation of the stream. Default `false`.\n * @example\n *\n * import { collect } from 'catchment'\n * import { createReadStream } from 'fs'\n *\n * const rs = createReadStream(path)\n * await collect(rs, { proxyError: true })\n */\nexport const collect = async (readable, options = {}) => {\n  const { promise } = new Catchment({\n    rs: readable,\n    ...options,\n    er: erotic(true),\n  })\n  const res = await promise\n  return res\n}\n\n/* typal types/index.xml */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {_catchment.Options} Options Options to pass to the `Writable` super constructor, and others shown below.\n */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {Object} _catchment.Options Options to pass to the `Writable` super constructor, and others shown below.\n * @prop {!stream.Readable} [rs] A readable stream to automatically pipe into the catchment. If an error occurs during reading of this stream, the catchment promise will be rejected with it.\n * @prop {boolean} [binary=false] Whether to return a raw buffer instead of a string. The string is created by joining all incoming chunks together with `.join('')` method. Default `false`.\n */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {import('stream').Readable} stream.Readable\n */\n\n/* typal types/collect.xml */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {_catchment.CollectOptions} CollectOptions Options when collecting data into a catchment. They can extend `Writable` options which will be passed to the `Catchment` constructor.\n */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {Object} _catchment.CollectOptions Options when collecting data into a catchment. They can extend `Writable` options which will be passed to the `Catchment` constructor.\n * @prop {boolean} [binary=false] Whether to return a raw buffer instead of a string. The string is created by joining all incoming chunks together with `.join('')` method. Default `false`.\n * @prop {boolean} [proxyError=false] Sets whether an error emitted by the stream with have its stack start at the line where the `collect` was called rather than inside of the stream. In other words, hides the implementation of the stream. Default `false`.\n */\n","import { createReadStream } from 'fs'\nimport { collect } from 'catchment'\n\n/**\n * Read a file.\n * @param {string} path The path to the file to read.\n */\nexport default async function read(path) {\n  const rs = createReadStream(path)\n  /** @type {string} */\n  const res = await collect(rs)\n  return res\n}\n\n/**\n * Read a file as a buffer.\n * @param {string} path The path to the file to read.\n */\nexport async function readBuffer(path) {\n  const rs = createReadStream(path)\n  /** @type {Buffer} */\n  const res = await collect(rs, { binary: true })\n  return res\n}","export default tty\nexport const {\n  ReadStream,\n  WriteStream,\n  isatty,\n} = tty","export default util\nexport const {\n  TextDecoder,\n  TextEncoder,\n  callbackify,\n  debug,\n  debuglog,\n  deprecate,\n  error,\n  format,\n  getSystemErrorName,\n  inherits,\n  inspect,\n  isArray,\n  isBoolean,\n  isBuffer,\n  isDate,\n  isError,\n  isFunction,\n  isNull,\n  isNullOrUndefined,\n  isNumber,\n  isObject,\n  isPrimitive,\n  isRegExp,\n  isString,\n  isSymbol,\n  isUndefined,\n  log,\n  print,\n  promisify,\n  puts,\n} = util","/**\n * Helpers.\n */\n\nvar s = 1000\nvar m = s * 60\nvar h = m * 60\nvar d = h * 24\nvar w = d * 7\nvar y = d * 365.25\n\n/**\n * Parse or format the given `val`.\n *\n * Options:\n *\n *  - `long` verbose formatting [false]\n *\n * @param {string|number} val\n * @param {Object} [options]\n */\nexport default function(val, options = {}) {\n  var type = typeof val\n  if (type == 'string' && val.length > 0) {\n    const t = /** @type {string} */ (val)\n    return parse(t)\n  } else if (type == 'number' && isFinite(val)) {\n    const n = /** @type {number} */ (val)\n    return options.long ? fmtLong(n) : fmtShort(n)\n  }\n  throw new Error(\n    'val is not a non-empty string or a valid number. val=' +\n      JSON.stringify(val)\n  )\n}\n\n/**\n * Parse the given `str` and return milliseconds.\n *\n * @param {string} str\n * @api private\n */\nfunction parse(str) {\n  str = String(str)\n  if (str.length > 100) {\n    return\n  }\n  var match = /^(-?(?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(\n    str\n  )\n  if (!match) {\n    return\n  }\n  var n = parseFloat(match[1])\n  var type = (match[2] || 'ms').toLowerCase()\n  switch (type) {\n  case 'years':\n  case 'year':\n  case 'yrs':\n  case 'yr':\n  case 'y':\n    return n * y\n  case 'weeks':\n  case 'week':\n  case 'w':\n    return n * w\n  case 'days':\n  case 'day':\n  case 'd':\n    return n * d\n  case 'hours':\n  case 'hour':\n  case 'hrs':\n  case 'hr':\n  case 'h':\n    return n * h\n  case 'minutes':\n  case 'minute':\n  case 'mins':\n  case 'min':\n  case 'm':\n    return n * m\n  case 'seconds':\n  case 'second':\n  case 'secs':\n  case 'sec':\n  case 's':\n    return n * s\n  case 'milliseconds':\n  case 'millisecond':\n  case 'msecs':\n  case 'msec':\n  case 'ms':\n    return n\n  default:\n    return undefined\n  }\n}\n\n/**\n * Short format for `ms`.\n *\n * @param {number} ms\n * @api private\n */\nfunction fmtShort(ms) {\n  var msAbs = Math.abs(ms)\n  if (msAbs >= d) {\n    return Math.round(ms / d) + 'd'\n  }\n  if (msAbs >= h) {\n    return Math.round(ms / h) + 'h'\n  }\n  if (msAbs >= m) {\n    return Math.round(ms / m) + 'm'\n  }\n  if (msAbs >= s) {\n    return Math.round(ms / s) + 's'\n  }\n  return ms + 'ms'\n}\n\n/**\n * Long format for `ms`.\n *\n * @param {number} ms\n * @api private\n */\nfunction fmtLong(ms) {\n  var msAbs = Math.abs(ms)\n  if (msAbs >= d) {\n    return plural(ms, msAbs, d, 'day')\n  }\n  if (msAbs >= h) {\n    return plural(ms, msAbs, h, 'hour')\n  }\n  if (msAbs >= m) {\n    return plural(ms, msAbs, m, 'minute')\n  }\n  if (msAbs >= s) {\n    return plural(ms, msAbs, s, 'second')\n  }\n  return ms + ' ms'\n}\n\n/**\n * Pluralization helper.\n */\n\nfunction plural(ms, msAbs, n, name) {\n  var isPlural = msAbs >= n * 1.5\n  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '')\n}\n\n/**\n * @license\n * Copyright (c) 2016 Zeit, Inc.\n * https://npmjs.org/ms\n */","/*!\n * bytes\n * Copyright(c) 2012-2014 TJ Holowaychuk\n * Copyright(c) 2015 Jed Watson\n * MIT Licensed\n */\n\nconst formatThousandsRegExp = /\\B(?=(\\d{3})+(?!\\d))/g\nconst formatDecimalsRegExp = /(?:\\.0*|(\\.[^0]+)0+)$/\n\nconst map = {\n  'b':  1,\n  'kb': 1 << 10,\n  'mb': 1 << 20,\n  'gb': 1 << 30,\n  'tb': Math.pow(1024, 4),\n  'pb': Math.pow(1024, 5),\n}\n\nconst parseRegExp = /^((-|\\+)?(\\d+(?:\\.\\d+)?)) *(kb|mb|gb|tb|pb)$/i\n\n/**\n * Convert the given value in bytes into a string or parse to string to an integer in bytes.\n *\n * @param {string|number} value\n * @param {{\n *  case: (string|undefined),\n *  decimalPlaces: (number|undefined),\n *  fixedDecimals: (boolean|undefined),\n *  thousandsSeparator: (string|undefined),\n *  unitSeparator: (string|undefined),\n *  }} [options] bytes options.\n *\n * @returns {?(string|number)}\n */\n\nexport default function bytes(value, options) {\n  if (typeof value == 'string') {\n    return parse(value)\n  }\n\n  if (typeof value == 'number') {\n    return format(value, options)\n  }\n\n  return null\n}\n\n/**\n * Format the given value in bytes into a string.\n *\n * If the value is negative, it is kept as such. If it is a float,\n * it is rounded.\n *\n * @param {number} value\n * @param {Object} [options]\n * @param {number} [options.decimalPlaces=2]\n * @param {number} [options.fixedDecimals=false]\n * @param {string} [options.thousandsSeparator=]\n * @param {string} [options.unit=]\n * @param {string} [options.unitSeparator=]\n * @returns {?string}\n */\nexport function format(value, options) {\n  if (!Number.isFinite(value)) {\n    return null\n  }\n\n  const mag = Math.abs(value)\n  const thousandsSeparator = (options && options.thousandsSeparator) || ''\n  const unitSeparator = (options && options.unitSeparator) || ''\n  const decimalPlaces = (options && options.decimalPlaces !== undefined) ? options.decimalPlaces : 2\n  const fixedDecimals = Boolean(options && options.fixedDecimals)\n  let unit = (options && options.unit) || ''\n\n  if (!unit || !map[unit.toLowerCase()]) {\n    if (mag >= map['pb']) {\n      unit = 'PB'\n    } else if (mag >= map['tb']) {\n      unit = 'TB'\n    } else if (mag >= map['gb']) {\n      unit = 'GB'\n    } else if (mag >= map['mb']) {\n      unit = 'MB'\n    } else if (mag >= map['kb']) {\n      unit = 'KB'\n    } else {\n      unit = 'B'\n    }\n  }\n\n  const val = value / map[unit.toLowerCase()]\n  let str = val.toFixed(decimalPlaces)\n\n  if (!fixedDecimals) {\n    str = str.replace(formatDecimalsRegExp, '$1')\n  }\n\n  if (thousandsSeparator) {\n    str = str.replace(formatThousandsRegExp, thousandsSeparator)\n  }\n\n  return str + unitSeparator + unit\n}\n\n/**\n * Parse the string value into an integer in bytes.\n *\n * If no unit is given, it is assumed the value is in bytes.\n *\n * @param {number|string} val\n *\n * @returns {number|null}\n * @public\n */\n\nexport function parse(val) {\n  if (typeof val == 'number' && !isNaN(val)) {\n    return val\n  }\n\n  if (typeof val != 'string') {\n    return null\n  }\n\n  // Test if the string passed is valid\n  const results = parseRegExp.exec(val)\n  let floatValue, unit = 'b'\n\n  if (!results) {\n    // Nothing could be extracted from the given string\n    floatValue = parseInt(val, 10)\n    unit = 'b'\n  } else {\n    // Retrieve the value and the unit\n    floatValue = parseFloat(results[1])\n    unit = results[4].toLowerCase()\n  }\n\n  return Math.floor(map[unit] * floatValue)\n}","import Diff from './diff'\n\nconst colors = {\n  'black': 30,\n  'red': 31,\n  'green': 32,\n  'yellow': 33,\n  'blue': 34,\n  'magenta': 35,\n  'cyan': 36,\n  'white': 37,\n  'grey': 90,\n}\n\nconst backgroundColors = {\n  'black': 40,\n  'red': 41,\n  'green': 42,\n  'yellow': 43,\n  'blue': 44,\n  'magenta': 45,\n  'cyan': 46,\n  'white': 47,\n}\n\n/**\n * Color the foreground.\n * @param {string} string The string to color.\n * @param {_erte.Color} color The color to apply.\n */\nexport function c(string, color) {\n  const cc = colors[color]\n  if (!cc) return string\n  return `\\x1b[${cc}m${string}\\x1b[0m`\n}\n\n/**\n * Color the background.\n * @param {string} string The string to color.\n * @param {_erte.Color} color The color to apply.\n */\nexport function b(string, color) {\n  const cc = backgroundColors[color]\n  if (!cc) return string\n  return `\\x1b[${cc}m${string}\\x1b[0m`\n}\n\n/**\n * Compares two strings and outputs a coloured version where strings don't match.\n * @param {string} source A string to compare.\n * @param {string} target Target string to compare with.\n * @returns {string} A string which uses shell-codes to highligh differences.\n */\nexport default function erte(source, target) {\n  const diff = new Diff()\n  const d = diff.diff(source, target)\n  const m = d.map(({ added, removed, value }) => {\n    let p\n    const s = value.split(' ')\n    if (added) {\n      p = s.map(t => {\n        return t.replace(/\\n$/mg, '\u23ce\\n')\n      }).map(t => c(t, 'green')).join(b(' ', 'green'))\n    } else if (removed) {\n      p = s.map(t => {\n        return t.replace(/\\n$/mg, '\u23ce\\n')\n      }).map(t => c(t, 'red')).join(b(' ', 'red'))\n    } else {\n      p = c(value, 'grey')\n    }\n    return p\n  })\n  const s = m.join('')\n  return s\n}\n\n/* documentary types/index.xml */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {_erte.Color} Color The color to apply.\n */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {('black'|'red'|'green'|'yellow'|'blue'|'magenta'|'cyan'|'white'|'grey')} _erte.Color The color to apply.\n */\n","import { format } from '../bytes'\nimport { c } from 'erte'\n\nexport default {\n  'f': format,\n  'fy'(v) {\n    return c(format(v) || '', 'yellow')\n  },\n  'fr'(v) {\n    return c(format(v) || '', 'red')\n  },\n  'fb'(v) {\n    return c(format(v) || '', 'blue')\n  },\n  'fg'(v) {\n    return c(format(v) || '', 'green')\n  },\n  'fc'(v) { return c(format(v) || '', 'cyan') },\n  'fm'(v) { return c(format(v) || '', 'magenta') },\n}\n","import tty from 'tty'\nimport { inspect, format } from 'util'\nimport ms from './ms'\nimport f from './modifiers/f'\n\nconst colors = [6, 2, 3, 4, 5, 1]\n\n/**\n * Build up the default `inspectOpts` object from the environment variables.\n *\n *   $ DEBUG_COLORS=no DEBUG_DEPTH=10 DEBUG_SHOW_HIDDEN=enabled node script.js\n */\nconst inspectOpts = Object.keys(process.env).filter(key => {\n  return /^debug_/i.test(key)\n}).reduce((obj, key) => {\n  // Camel-case\n  const prop = key\n    .substring(6)\n    .toLowerCase()\n    .replace(/_([a-z])/g, (_, k) => {\n      return k.toUpperCase()\n    })\n\n  // Coerce string value into JS value\n  let val = process.env[key]\n  if (/^(yes|on|true|enabled)$/i.test(val)) {\n    val = true\n  } else if (/^(no|off|false|disabled)$/i.test(val)) {\n    val = false\n  } else if (val === 'null') {\n    val = null\n  } else {\n    val = Number(val)\n  }\n\n  obj[prop] = val\n  return obj\n}, {})\n\n/**\n * Is stdout a TTY? Colored output is enabled when `true`.\n */\nfunction useColors() {\n  return 'colors' in inspectOpts ?\n    Boolean(inspectOpts['colors']) :\n    tty.isatty(process.stderr.fd)\n}\n\n/**\n * Adds ANSI color escape codes if enabled.\n * @param {!Array} args\n * @this {_debug.DebugFunction}\n */\nfunction formatArgs(args) {\n  const { namespace, useColors: uc, color, diff } = this\n\n  if (uc) {\n    const c = color\n    const colorCode = '\\u001B[3' + (c < 8 ? c : '8;5;' + c)\n    const prefix = `  ${colorCode};1m${namespace} \\u001B[0m`\n\n    args[0] = prefix + args[0].split('\\n').join('\\n' + prefix)\n    args.push(colorCode + 'm+' + ms(diff) + '\\u001B[0m')\n  } else {\n    args[0] = getDate() + namespace + ' ' + args[0]\n  }\n}\n\nfunction getDate() {\n  if (inspectOpts['hideDate']) {\n    return ''\n  }\n  return new Date().toISOString() + ' '\n}\n\n/**\n * Invokes `util.format()` with the specified arguments and writes to stderr.\n */\nfunction log(...args) {\n  return process.stderr.write(format(...args) + '\\n')\n}\n\n/**\n * Save `namespaces`.\n * @param {string} namespaces\n */\nfunction save(namespaces) {\n  if (namespaces) {\n    process.env['DEBUG'] = namespaces\n  } else {\n    // If you set a process.env field to null or undefined, it gets cast to the\n    // string 'null' or 'undefined'. Just delete instead.\n    delete process.env['DEBUG']\n  }\n}\n\n/**\n * Load `namespaces`.\n * @return {string} returns the previously persisted debug modes\n */\n\nfunction load() {\n  return process.env['DEBUG']\n}\n\n/**\n * Init logic for `debug` instances.\n * @param {_debug.DebugFunction} debug\n *\n * Create a new `inspectOpts` object in case `useColors` is set\n * differently for a particular `debug` instance.\n */\n\nfunction init(debug) {\n  debug.inspectOpts = { ...inspectOpts }\n}\n\n/**\n * Map %o to `util.inspect()`, all on a single line.\n * @param {Object} v\n * @this {_debug.DebugFunction}\n */\nconst o = function(v) {\n  const opts = {\n    ...this.inspectOpts,\n    colors: this.useColors,\n  }\n  return inspect(v, opts)\n    .replace(/\\s*\\n\\s*/g, ' ')\n}\n\n/**\n * Map %O to `util.inspect()`, allowing multiple lines if needed.\n * @param {Object} v\n * @this {_debug.DebugFunction}\n */\nconst O = function(v) {\n  const opts = {\n    ...this.inspectOpts,\n    colors: this.useColors,\n  }\n  return inspect(v, opts)\n}\n\nconst formatters = { 'o': o, 'O': O, ...f }\n\n/** @type {_debug.Env} */\nconst NodeEnv = {\n  init,\n  log,\n  formatArgs,\n  save,\n  load,\n  useColors,\n  colors,\n  inspectOpts,\n  formatters,\n}\n\nexport default NodeEnv\n\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {import('../types').DebugFunction} _debug.DebugFunction\n */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {import('../types').Env} _debug.Env\n */","class Debug {\n  /**\n   * Create a debugger with the given `namespace`.\n   * @param {_debug.Env} env\n   */\n  constructor(env) {\n    this.colors = env.colors\n    this.formatArgs = env.formatArgs\n    this.inspectOpts = env.inspectOpts\n    this.log = env.log\n    this.save = env.save\n    this.init = env.init\n\n    this.formatters = env.formatters || {}\n\n    /**\n     * Active `debug` instances.\n     * @type {Array<_debug.DebugFunction>}\n     */\n    this.instances = []\n    /**\n\t   * The currently active debug mode names.\n     * @type {Array<!RegExp>}\n\t   */\n    this.names = []\n    /**\n\t   * The currently active names to skip.\n     * @type {Array<!RegExp>}\n\t   */\n    this.skips = []\n  }\n  createDebug() {\n    const debug = this.getDebug()\n\n    // env-specific initialization logic for debug instances\n    if (typeof this.init == 'function') {\n      this.init(debug)\n    }\n\n    this.instances.push(debug)\n    return debug\n  }\n\n  /**\n   * @returns {_debug.DebugFunction}\n   */\n  getDebug() {\n    const formatters = this.formatters\n    const formatArgs = this.formatArgs\n    const log = this.log // comes from the env\n\n    /** @type {number} */\n    let prevTime\n    /** @type {_debug.DebugFunction} */\n    function debug(...args) {\n      if (!debug.enabled) return\n\n      // Set `diff` timestamp\n      const curr = Number(new Date())\n      const time = curr - (prevTime || curr)\n      debug.diff = time\n      debug.prev = prevTime\n      debug.curr = curr\n      prevTime = curr\n\n      args[0] = coerce(args[0])\n\n      if (typeof args[0] != 'string') {\n        // Anything else let's inspect with %O\n        args.unshift('%O')\n      }\n\n      // Apply any `formatters` transformations\n      let index = 0\n      args[0] = args[0].replace(/%([a-zA-Z%]+)/g, (match, format) => {\n        // If we encounter an escaped % then don't increase the array index\n        if (match == '%%') {\n          return match\n        }\n        index++\n        const formatter = formatters[format]\n        if (formatter) {\n          const val = args[index]\n          match = formatter.call(debug, val)\n\n          // Now we need to remove `args[index]` since it's inlined in the `format`\n          args.splice(index, 1)\n          index--\n        }\n        return match\n      })\n\n      // Apply env-specific formatting (colors, etc.)\n      formatArgs.call(debug, args)\n\n      const logFn = debug.log || log\n      logFn.apply(debug, args)\n    }\n    return debug\n  }\n  /**\n\t * Selects a color for a debug namespace\n\t * @param {string} namespace The namespace string for the for the debug instance to be colored\n\t * @return {number|string} An ANSI color code for the given namespace\n\t */\n  selectColor(namespace) {\n    let hash = 0\n\n    for (let i = 0; i < namespace.length; i++) {\n      hash = ((hash << 5) - hash) + namespace.charCodeAt(i)\n      hash |= 0 // Convert to 32bit integer\n    }\n\n    return this.colors[Math.abs(hash) % this.colors.length]\n  }\n  /**\n\t * Enables a debug mode by namespaces. This can include modes\n\t * separated by a colon and wildcards.\n\t *\n\t * @param {string} namespaces\n\t * @api public\n\t */\n  enable(namespaces) {\n    this.save(namespaces)\n\n    this.names = []\n    this.skips = []\n\n    let i\n    const split = (typeof namespaces == 'string' ? namespaces : '').split(/[\\s,]+/)\n    const len = split.length\n\n    for (i = 0; i < len; i++) {\n      if (!split[i]) {\n        // ignore empty strings\n        continue\n      }\n\n      namespaces = split[i].replace(/\\*/g, '.*?')\n\n      if (namespaces[0] == '-') {\n        this.skips.push(new RegExp('^' + namespaces.substr(1) + '$'))\n      } else {\n        this.names.push(new RegExp('^' + namespaces + '$'))\n      }\n    }\n\n    for (i = 0; i < this.instances.length; i++) {\n      const instance = this.instances[i]\n      instance.enabled = this.enabled(instance.namespace)\n    }\n  }\n  destroy(debug) {\n    const index = this.instances.indexOf(debug)\n    if (index !== -1) {\n      this.instances.splice(index, 1)\n      return true\n    }\n    return false\n  }\n  /**\n\t * Disable debug output.\n\t * @return {string} namespaces\n\t */\n  disable() {\n    const namespaces = [\n      ...this.names.map(toNamespace),\n      ...this.skips.map(toNamespace).map(namespace => '-' + namespace),\n    ].join(',')\n    this.enable('')\n    return namespaces\n  }\n  /**\n\t * Returns true if the given mode name is enabled, false otherwise.\n\t * @param {string} name\n\t * @return {boolean}\n\t */\n  enabled(name) {\n    if (name[name.length - 1] == '*') {\n      return true\n    }\n\n    let i\n    let len\n\n    for (i = 0, len = this.skips.length; i < len; i++) {\n      if (this.skips[i].test(name)) {\n        return false\n      }\n    }\n\n    for (i = 0, len = this.names.length; i < len; i++) {\n      if (this.names[i].test(name)) {\n        return true\n      }\n    }\n\n    return false\n  }\n}\n\n/**\n * @param {string} namespace\n * @this {_debug.DebugContext}\n */\nfunction extend(namespace, delimiter) {\n\n}\n\n/**\n * This is the common logic for both the Node.js and web browser implementations of `debug()`.\n * @param {_debug.Env} env\n */\nexport default function setup(env) {\n  const instance = new Debug(env)\n\n  /**\n   * Creates a function to log messages.\n   * @param {string} namespace\n   */\n  function createDebug(namespace) {\n    const debug = instance.createDebug()\n\n    debug.namespace = namespace\n    debug.useColors = env.useColors()\n    debug.enabled = instance.enabled(namespace)\n    debug.color = instance.selectColor(namespace)\n    /** @this {_debug.DebugContext} */\n    debug.destroy = function() {\n      instance.destroy(this)\n    }\n    /** @this {_debug.DebugContext} */\n    debug.extend = function(ns, delimiter) {\n      const newDebug = (this.namespace + (delimiter === undefined ? ':' : delimiter) + ns)\n      newDebug.log = this.log // don't know why this is here\n      return newDebug\n    }\n\n    instance.enable(env.load())\n\n    return debug\n  }\n  return createDebug\n}\n\n/**\n * Convert regexp to namespace.\n *\n * @param {!RegExp} regexp\n * @return {string} namespace\n * @private\n */\nfunction toNamespace(regexp) {\n  return regexp.toString()\n    .substring(2, regexp.toString().length - 2)\n    .replace(/\\.\\*\\?$/, '*')\n}\n\n/**\n * Coerce `val`.\n * @param {!Error|*} val\n * @return {*}\n * @private\n */\nfunction coerce(val) {\n  if (val instanceof Error) {\n    return val.stack || val.message\n  }\n  return val\n}\n\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {import('.').Env} _debug.Env\n */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {import('.').DebugFunction} _debug.DebugFunction\n */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {import('.').DebugContext} _debug.DebugContext\n */","import { readBuffer } from '@wrote/read'\nimport Debug from '@idio/debug'\n\nconst debug=Debug('@multipart/form')\n\n/**\n * @implements {_multipart.Form}\n */\nexport default class Form {\n  /**\n   * Creates a new form instance that maintains a buffer of key-value pairs and files separated by a boundary.\n   * @param {_multipart.FormConfig} [opts] Options for the constructor.\n   * @param {string} [opts.boundary=\"u2KxIV5yF1y+xUspOQCCZopaVgeV6Jxihv35XQJmuTx8X3sh\"] The hard-coded boundary for the requests. Default `u2KxIV5yF1y+xUspOQCCZopaVgeV6Jxihv35XQJmuTx8X3sh`.\n   */\n  constructor(opts = {}) {\n    const {\n      boundary = 'u2KxIV5yF1y+xUspOQCCZopaVgeV6Jxihv35XQJmuTx8X3sh',\n    } = opts\n    /**\n     * @type {!Array<!Buffer>}\n     */\n    this._data = []\n    this._boundary = boundary\n  }\n  /**\n   * @param {string} path The path to the file.\n   * @param {string} name The name of the field.\n   * @param {_multipart.AddFileOptions} [options] Options for adding files.\n   * @param {string} [options.type=\"application/octet-stream\"] The _Content-Type_ description. Default `application/octet-stream`.\n   * @param {boolean} [options.noCache=false] Whether to not cache read files. Default `false`.\n   * @param {string} [options.filename] The `filename` property for _Content-Disposition_ description. By default, will be same as the `path` argument.\n   */\n  async addFile(path, name, options = {}) {\n    const {\n      contentType = 'application/octet-stream',\n      noCache = false,\n      filename = path,\n    } = options\n    let file\n    if (path in formCache || noCache) {\n      file = formCache[path]\n    } else {\n      file = await readBuffer(path)\n      if (!noCache) formCache[path] = file\n    }\n    const disposition = [\n      'form-data',\n      `name=\"${name}\"`,\n      `filename=\"${filename}\"`,\n    ].join('; ')\n    this.writeLine(`\\r\\n--${this.boundary}`)\n    this.writeLine(`Content-Disposition: ${disposition}`)\n    this.writeLine(`Content-Type: ${contentType}`)\n    this.writeLine()\n    this._data.push(file)\n  }\n  writeLine(line = null, encoding = 'utf8') {\n    if (line)\n      this._data.push(typeof line == 'string' ? Buffer.from(line, encoding) : line)\n\n    this._data.push(Buffer.from('\\r\\n', encoding))\n  }\n  /**\n   * The boundary.\n   */\n  get boundary() {\n    return this._boundary\n  }\n  /**\n   * The complete data as a string.\n   */\n  get data() {\n    let b = this.buffer\n    debug('converting to string')\n    b = b.toString()\n    debug('string is %f', b.length)\n    return b\n  }\n  /**\n   * The complete data as Buffer.\n   */\n  get buffer() {\n    debug('adding final --boundary-- and calling Buffer.concat')\n    this.writeLine(`\\r\\n--${this.boundary}--`)\n\n    let b= Buffer.concat(this._data)\n    debug('buffer is %f', b.length)\n    return b\n  }\n  /**\n   * Adds a key-value pair to the form.\n   * @param {string} key The key to add.\n   * @param {!Buffer|string} value The value for the key.\n   */\n  addSection(key, value) {\n    this.writeLine(`\\r\\n--${this.boundary}`)\n    this.writeLine(`Content-Disposition: form-data; name=\"${key}\"`)\n    this.writeLine()\n    this._data.push(value instanceof Buffer ? value : Buffer.from(value))\n  }\n}\n\nconst formCache = {}\n\n/* typal types/index.xml closure */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {_multipart.Config} Config Options for the constructor.\n */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {Object} _multipart.Config Options for the constructor.\n * @prop {string} [boundary=\"u2KxIV5yF1y+xUspOQCCZopaVgeV6Jxihv35XQJmuTx8X3sh\"] The hard-coded boundary for the requests. Default `u2KxIV5yF1y+xUspOQCCZopaVgeV6Jxihv35XQJmuTx8X3sh`.\n */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {_multipart.AddFileOptions} AddFileOptions Options for adding files.\n */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {Object} _multipart.AddFileOptions Options for adding files.\n * @prop {string} [type=\"application/octet-stream\"] The _Content-Type_ description. Default `application/octet-stream`.\n * @prop {boolean} [noCache=false] Whether to not cache read files. Default `false`.\n * @prop {string} [filename] The `filename` property for _Content-Disposition_ description. By default, will be same as the `path` argument.\n */\n","import NodeEnv from './node'\nimport setup from './common'\n\n/**\n * Creates a function to log messages.\n * @param {string} namespace\n */\nexport default function(namespace) {\n  if (!namespace) throw new Error('To use debug, pass the namespace.')\n  const node = setup(NodeEnv)\n  const debug = node(namespace)\n  return debug\n}","import '../types/externs'\nimport Form from './'\n\nmodule.exports = Form"],
"names":["createReadStream","fs","Writable","stream","getStackSegment","stack","from","oneLine","splitStack","split","undefined","item","length","slice","items","join","getEntryStack","transparent","stackSegment","getCallerFromArguments","args","caller","homedir","os","extractPathRegex","pathRegex","homeDir","cleanStack","pretty","ignoredModules","re","RegExp","source","replace","j","filter","x","pathMatches","match","includes","test","trim","map","m","p1","makeCallback","entryCaller","entryStack","shadow","cb","messageOrError","arguments","errorStack","Error","calleeStackLine","message","isError","stackMessage","stackHeading","Object","assign","e","properties","erotic","pipeError","streamA","streamB","once","emit","Catchment","options","binary","rs","opts","er","proxyError","wrap","_","_caughtData","_promise","Promise","r","on","d","Buffer","concat","indexOf","pipe","chunk","encoding","callback","push","collect","readable","promise","res","readBuffer","path","$jscompDefaultExport","tty","format","util","inspect","val","type","parse","isFinite","long","msAbs","Math","abs","ms","plural","h","s","round","JSON","stringify","str","String","exec","n","parseFloat","toLowerCase","y","w","name","formatThousandsRegExp","formatDecimalsRegExp","pow","value","Number","mag","thousandsSeparator","unitSeparator","decimalPlaces","fixedDecimals","unit","toFixed","colors","c","string","color","cc","v","inspectOpts","keys","process","env","key","reduce","obj","prop","substring","k","toUpperCase","NodeEnv","init","debug","log","stderr","write","formatArgs","namespace","diff","uc","colorCode","prefix","toISOString","Date","save","namespaces","load","useColors","isatty","fd","formatters","o","O","f","getDebug","enabled","curr","prevTime","prev","coerce","unshift","index","formatter","call","splice","apply","createDebug","instances","selectColor","hash","i","charCodeAt","enable","names","skips","len","substr","instance","Debug","setup","destroy","debug.destroy","extend","debug.extend","ns","delimiter","newDebug","node","writeLine","line","_data","Form","boundary","_boundary","contentType","noCache","filename","formCache","file","disposition","b","buffer","toString","module","exports"]
}
